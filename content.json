[{"title":"测试","date":"2017-03-21T14:42:29.000Z","path":"2017/03/21/测试/","text":"[TOC] 1. 测试11.11.22. 测试2123public static void main() &#123; System.out.println(\"Hello World\");&#125; 3. 测试图片3","tags":[{"name":"--markdown展示","slug":"markdown展示","permalink":"http://crystalxiaoou.github.io/tags/markdown展示/"}]},{"title":"java与模式学习笔记之依赖倒转原则","date":"2017-02-19T02:51:36.000Z","path":"2017/02/19/设计模式之依赖倒转原则/","text":"1.三种耦合关系 在面向对象的系统中，两个类之间可以发生三种不同的耦合关系： 零耦合关系: 两个类直接没有耦合关系 具体耦合关系: 两个具体（可实例化）类之间，一个类对另一个具体类的直接引用造成 抽象耦合关系: 一个具体类和一个抽象类(OR java接口)之间,使两个必须发生关系的类之间具有最大的灵活性 2.什么是依赖倒转原则 依赖倒转原则要求客户端依赖于抽象耦合。抽象不依赖与细节，细节依赖与抽象。要面向接口编程，不针对实现编程。依赖倒转关系强调一个系统内的实体之间关系的灵活。依赖倒转是到达『开-闭』原则的途径。 3.怎么做到依赖倒转原则 以抽象方式耦合是依赖倒转原则的关键。里氏替换原则是依赖倒转原则的基础。","tags":[{"name":"依赖倒转原则","slug":"依赖倒转原则","permalink":"http://crystalxiaoou.github.io/tags/依赖倒转原则/"}]},{"title":"继承的理解","date":"2017-01-11T12:49:10.000Z","path":"2017/01/11/继承的理解/","text":"继承应当被看做是封装变化的方法，而不应当被认为是从一般的对象生成特殊的对象的方法。","tags":[{"name":"继承","slug":"继承","permalink":"http://crystalxiaoou.github.io/tags/继承/"}]},{"title":"","date":"2017-01-10T09:35:48.000Z","path":"2017/01/10/1.与重股交联调遇到的问题/","text":"1.与重股交联调遇到的问题（1）问题： 为重股交的访问IP添加访问权限时，重股交给的IP错误，导致一直连接不上资管的SFTP服务器 解决方案： 找OP 查看SFTP 服务器访问日志，发现访问IP 与所给的IP 不一致 （2）问题： 给重股交的SFTP联调环境参数时，SFTP服务器的端口号 给错了 解决方案： 通过重股交贴出来的连接命令的截图发现端口错误 （3）问题：资管跟重股交传输文件时的SFTP用户子文件夹 不太合理，容易导致排查困难等问题 解决：通过沟通后，从放在download/日期, upload/日期 目录下改为只放在日期目录下 (4) 问题：重股交拉取资管上传到SFTP的交易申请文件时，因为文件名编码配置错误，拉取失败 解决方案：根据资管之前拉取SFTP文件的经验，提供两种方案给重股交，顺利解决问题 （5）问题：重股交之前用的是Apache的一个FTP Client客户端工具拉取文件，发现不能跟SFTP服务器交互 解决方案：通过与资管沟通后， 替换为jsch SFTP开源库连接 （6）问题：重股交解析资管生成的交易申请文件时，总共19列，只能解析17列 解决方案：资管用跟重股交使用的javacsv库解析同样的文件没有问题，最后定位为双方文件编码不一致导致 (7) 问题：重股交生成的产品托管表、还款试算文件的文件名中日期 以及存放的文件夹与之前约定的存在出入 解决方案： 通过沟通后，约定了文件名生成规则和文件夹存放规则 2.与销售平台联调遇到的问题（1）问题：交易确认文件中的交易所帐号字段 为必填，之前武交所这个字段是武交所用理财交易帐号代替的。资管本次生成的时候这个字段直接从交易表中读取，故文件中该字段为32个空格。销售平台解析的时候对该字段做了必填校验，但是他们的失败日志为字段长度不对，导致排查方向错误。解决方案: 对比线上和本次生成的交易确认文件，发现只有这个字段不一样，用理财交易帐号代替后，解析成功。 以上为本次遇到问题及解决措施，希望对后续联调有帮助！","tags":[]},{"title":"JMS开发步骤和持久化/非持久化Topic消息","date":"2017-01-06T10:19:46.000Z","path":"2017/01/06/JMS开发步骤和持久化-非持久化Topic消息/","text":"1 开发一个JMS的基本步骤如下: (1) 创建一个JMS connection factory (2) 通过connection factory来创建JMS connection (3) 启动JMS connection (4) 通过connection创建JMS session (5) 创建JMS destination (6) 创建JMS producer 或者创建JMS message,并设置destination (7) 创建JMS consumer 或者注册一个JMS message listener (8) 发送或者接受JMS message (9) 关闭所有的JMS资源(connection、session、producer、consumer等) 可以参考下图： 2 非持久的Topic消息示例 对于非持久化的消息，当发送方发送消息的时候: (1) 如果接收方不在线，则接收方永远也收不到这些消息了 (2) 如果接收方在线，则接收方会收到这些消息 2.1 消息发送程序123456789101112131415161718192021222324252627282930313233343536373839import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.Destination;import javax.jms.MessageProducer;import javax.jms.Session;import javax.jms.TextMessage;import org.apache.activemq.ActiveMQConnectionFactory;/*** 非持久化Topic消息发送者* @author crystal**/public class NoPersistenceSender &#123; public static void main(String[] args) throws Exception &#123; //创建一个JMS connection factory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.1.81:61616\"); //通过connection factory来创建JMS connection Connection connection = connectionFactory.createConnection(); //启动JMS connection connection.start(); //通过connection创建JMS session Session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE); //创建JMS destination Destination destination = session.createTopic(\"noPersistenceTopic\"); //创建JMS producer MessageProducer producer = session.createProducer(destination); for(int i = 0;i &lt; 10;i++)&#123; TextMessage message = session.createTextMessage(\"message-\"+i); //发送message producer.send(message); &#125; //关闭所有的JMS资源 session.commit(); session.close(); connection.close(); &#125; &#125; 运行完消息发送程序后，可以访问192.168.1.81:8161 2.2 消息接收程序 对于非持久的Topic消息的接收需要注意以下几点: a.接收程序必须在线，然后消息发送方再发送消息，接收程序才能接收到消息 b.由于不知道消息发送方要发送多少条消息，所以利用while循环的方式来接收消息 c.如果接收程序不在线，此时发送程序发送了消息的话，则该消息将永远不会被接收方收到。 1234567891011121314151617181920212223242526272829303132333435363738394041import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.Destination;import javax.jms.Message;import javax.jms.MessageConsumer;import javax.jms.Session;import javax.jms.TextMessage;import org.apache.activemq.ActiveMQConnectionFactory;/*** 非持久化Topic消息接收者* @author crystal**/public class NoPersistenceReceiver &#123; public static void main(String[] args) throws Exception &#123; //创建一个JMS connection factory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.1.81:61616\"); //通过connection factory来创建JMS connection Connection connection = connectionFactory.createConnection(); //启动JMS connection connection.start(); //通过connection创建JMS session Session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE); //创建JMS destination Destination destination = session.createTopic(\"noPersistenceTopic\"); //创建JMS consumer MessageConsumer consumer = session.createConsumer(destination); Message message = consumer.receive(); while(message != null)&#123; TextMessage txtMsg = (TextMessage)message; System.out.println(\"收到消息:\"+txtMsg.getText()); message = consumer.receive(); &#125; //关闭所有的JMS资源 session.commit(); session.close(); connection.close(); &#125; &#125; 3.持久的Topic消息示例3.1 消息发送程序 对于持久的Topic消息的发送方需要注意以下几点: a.要用持久化订阅，发送消息者要用DeliveryMode.PERSISTENT模式来发送 12345678910111213141516171819202122232425262728293031323334353637383940import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.DeliveryMode;import javax.jms.Destination;import javax.jms.MessageProducer;import javax.jms.Session;import javax.jms.TextMessage;import org.apache.activemq.ActiveMQConnectionFactory;/** * 持久化Topic消息发送者 * @author crystal */ public class PersistenceSender &#123; public static void main(String[] args) throws Exception &#123; //创建一个JMS connection factory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://192.168.1.81:61616\"); //通过connection factory来创建JMS connection Connection connection = connectionFactory.createConnection(); //通过connection创建JMS session Session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE); //创建JMS destination Destination destination = session.createTopic(\"PersistenceTopic\"); //创建JMS producer MessageProducer producer = session.createProducer(destination); producer.setDeliveryMode(DeliveryMode.PERSISTENT); //启动JMS connection connection.start(); for(int i = 0;i &lt; 10;i++)&#123; TextMessage message = session.createTextMessage(\"message-\"+i); //发送message producer.send(message); &#125; //关闭所有的JMS资源 session.commit(); session.close(); connection.close(); &#125; &#125; 3.2 消息接收程序 对于持久的Topic消息的接收方需要注意以下几点: a.需要在连接上设置消费者id,用来识别消费者 b.需要创建TopicSubscriber来订阅 c.一定要先运行一次该消费者程序，等于向消费服务中间件注册这个消费者，然后再运行消息发送者来发送消息，这样的话，无论消费者是否在线都会收到消息，如果不在线的话，则下次连接的时候会把没有收过的消息都接收下来。 123456789101112131415161718192021222324252627282930313233343536373839404142import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.Message;import javax.jms.Session;import javax.jms.TextMessage;import javax.jms.Topic;import javax.jms.TopicSubscriber;import org.apache.activemq.ActiveMQConnectionFactory; /** * 持久化Topic消息接收者 * @author crystal * */public class PersistenceReceiver &#123; public static void main(String[] args) throws Exception &#123; //创建一个JMS connection factory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.123.81:61616\"); //通过connection factory来创建JMS connection Connection connection = connectionFactory.createConnection(); connection.setClientID(\"con1\"); //通过connection创建JMS session Session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE); //创建JMS destination Topic destination = session.createTopic(\"PersistenceTopic\"); //创建JMS consumer TopicSubscriber ts = session.createDurableSubscriber(destination, \"TT\"); //启动JMS connection connection.start(); Message message = ts.receive(); while(message != null)&#123; TextMessage txtMsg = (TextMessage)message; session.commit(); System.out.println(\"收到消息:\"+txtMsg.getText()); message = ts.receive(1000L); &#125; //关闭所有的JMS资源 session.close(); connection.close(); &#125; &#125; 4. 关于持久化和非持久化消息4.1 有两种方式指定传送模式: (1) 使用setDeliveryMode方法，这样所有的消息都采用此传送模式;如producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT) (2) 使用send方法为每条消息设置传送模式 4.2 持久化消息 这是ActiveMQ的默认传送模式,此模式保证这些消息只被传送一次和成功使用一次。对于这些消息，可靠性是优先考虑的因素。可靠性的另一个重要方面是确保持久性消息传送至目标后，消息服务在向消费者传送它们之前不会丢失这些消息。 这意味着在持久性消息传送至目标时，消息服务将其放入持久性数据存储。如果消息服务由于某种原因导致失败，它可以恢复此消息并将此消息传送至相应的消费者。虽然这样增加了消息传送的开销，但是却增加了可靠性。 4.3 非持久化消息 保证这些消息最多被传送一次。对于这些消息，可靠性并非主要的考虑因素。此模式并不要求持久性的数据存储，也不保证消息服务由于某种原因导致失败后消息不会丢失。","tags":[{"name":"JSM开发步骤","slug":"JSM开发步骤","permalink":"http://crystalxiaoou.github.io/tags/JSM开发步骤/"},{"name":"持久化消息","slug":"持久化消息","permalink":"http://crystalxiaoou.github.io/tags/持久化消息/"},{"name":"非持久化消息","slug":"非持久化消息","permalink":"http://crystalxiaoou.github.io/tags/非持久化消息/"},{"name":"Topic","slug":"Topic","permalink":"http://crystalxiaoou.github.io/tags/Topic/"}]},{"title":"Java异常处理注意事项","date":"2017-01-06T05:24:51.000Z","path":"2017/01/06/Java异常处理注意事项/","text":"1. 包装运行时异常为自定义运行时异常 把系统运行时异常包装为自定义运行时异常抛出时，要把异常栈也一起抛出去。 示例代码如下: 123456789101112131415161718192021222324class Example &#123; public void exceptionMethod() &#123; try &#123; // throw a NullPointerException &#125;catch (NullPointerException nullException) &#123; logger.error(\"\", nullException); throw new AssetAccException(ErrorCodeEnum.FILE_DOWNLOAD_FAIL, nullException); &#125; &#125; public static void main(String[] args) &#123; try &#123; exceptionMethod(); &#125; catch(AssetAccException exception) &#123; // 打印异常栈信息到日志 LOGGER.err(exception); &#125; &#125;&#125;class AssetAccException extends RuntimeException &#123; public AssetAccException(ErrorCodeEnum errorEnum, Throwable cause) &#123; super(message, cause); &#125;&#125; 2. 私有、公有方法抛出的异常怎么处理 (1) 私有方法抛出的异常，一般都需要抛出到上层调用方法中(2) 公有方法抛出的异常，要么自己处理，要么抛出到上层调用方法中","tags":[{"name":"java异常处理","slug":"java异常处理","permalink":"http://crystalxiaoou.github.io/tags/java异常处理/"}]},{"title":"java文件处理注意点","date":"2017-01-06T05:15:50.000Z","path":"2017/01/06/java文件处理注意点/","text":"1. 文件处理时不要反复打开关闭流 (1) 使用java 写文件时，只要第一次打开文件流，之后都使用这个流进行写操作，然后flush即可。(2) 使用java 操作流时，可以使用IOUtils.quitelyClose()进行静默关闭流，这样就不用处理一堆IO异常啦。 2. 读文件时先打开一个流，再一行一行读 (1) 使用java 读文件时， 只要第一次打开文件流，之后都使用这个流进行读操作即可。(2) 不要使用Guava的Files.readLines()一次把所有文件内容都读到一个List中，这样会占用很多内存空间。","tags":[{"name":"Java流处理","slug":"Java流处理","permalink":"http://crystalxiaoou.github.io/tags/Java流处理/"},{"name":"Java文件处理","slug":"Java文件处理","permalink":"http://crystalxiaoou.github.io/tags/Java文件处理/"}]},{"title":"MySQL锁学习笔记","date":"2017-01-05T06:57:43.000Z","path":"2017/01/05/MySQL锁学习笔记/","text":"##1. Mysql锁概述 1.1 MySQL锁机制 MySQL锁机制比较简单，其显著的特点是不同的存储引擎支持不同的锁机制。MyISAM 和 MEMORY 存储引擎刺痛的是表级锁(table-level)。BDB存储引擎采用的是页面锁(page-level locking), 但也支持表级锁。InnoDB存储引擎既支持行级锁(row-level locking), 也支持表级锁但默认情况下采用行级锁。 1.2 MySQL三种锁的特性 表级锁: 开销小，加锁快； 不会出现死锁；锁定粒度大，发生锁冲突的概率最高， 并发度最低。 行级锁: 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。 页面锁: 开销和加锁时间介于表锁和行锁之间； 会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。 1.3 锁的选择 从三种锁的特性很难直接说哪种锁更好，只能就具体应用的特点来说哪种锁更合适!仅从锁的角度来说： (1) 行级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用。(2)行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理(OLTP)系统。 2. MyISAM表锁###2.1 查询表级锁争用情况 可以通过检查table_lock_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺,如下图所示。如果table_lock_waited的值比较高，则说明存在着较严重的表级锁争用情况。 ###2.2 MySQL表级锁的锁模式 MySQL的表级锁有两种模式: 表共享读锁(Table Read Lock) 和表独占写锁(Table Write Lock)。 锁模式的兼容性如下表所示: 当前锁模式 请求锁模式 是否兼容 读锁 None 是 读锁 读锁 是 读锁 写锁 否 写锁 None 是 写锁 读锁 否 写锁 写锁 否 （1）可见，对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一个表的写请求；（2）对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；（3）MyISAM表的读操作与写操作之间，以及写操作之间是串行的!（4）当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。 2.3 MySQL如何加表锁","tags":[{"name":"MYSQL锁","slug":"MYSQL锁","permalink":"http://crystalxiaoou.github.io/tags/MYSQL锁/"},{"name":"表级锁","slug":"表级锁","permalink":"http://crystalxiaoou.github.io/tags/表级锁/"},{"name":"行级锁","slug":"行级锁","permalink":"http://crystalxiaoou.github.io/tags/行级锁/"},{"name":"页面锁","slug":"页面锁","permalink":"http://crystalxiaoou.github.io/tags/页面锁/"}]},{"title":"Redis 命令学习","date":"2017-01-04T15:57:54.000Z","path":"2017/01/04/Redis-命令学习/","text":"1. 在数据库中创建一个值为String对象的键值对1redis&gt; SET msg &quot;hello world&quot; 键值对的键是一个字符串对象(对象底层实现是一个保存字符串”msg”的SDS) 键值对的值也是一个字符串对象 2. 在数据库中创建一个值为列表的键值对1redis&gt; RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot; 键值对的键是一个字符串对象(对象底层实现是一个保存字符串”msg”的SDS)键值对的值是一个列表对象，列表对象包含三个字符串对象","tags":[{"name":"Redis命令","slug":"Redis命令","permalink":"http://crystalxiaoou.github.io/tags/Redis命令/"}]},{"title":"重股交长度对照","date":"2017-01-04T07:00:00.000Z","path":"2017/01/04/重股交字段长度不OK 统计/","text":"重股交字段长度不OK 统计1. 所有文件中的金额、份额都没有写精确到几位小数2. 产品全称，产品简称长度比资管的小 来源 长度不OK字段 对应长度 Sale 产品行情文件 产品名称 40 资管DB产品表 项目名称 300 重股交 产品明细文件 产品全称，产品简称 20 3. 客户销售明细 里的客户姓名，客户全称字段长度比资管小 来源 长度不OK字段 对应长度 Sale 开户申请 客户名称 100 资管DB开户表 客户名称 100 重股交 客户销售明细 客户姓名，客户全称 64 4. 还款试算表 客户姓名同35. 产品托管表 客户姓名同3","tags":[{"name":"项目","slug":"项目","permalink":"http://crystalxiaoou.github.io/tags/项目/"}]},{"title":"CyclicBarrier和CountDownLatch的区别","date":"2017-01-02T12:11:49.000Z","path":"2017/01/02/CyclicBarrier和CountDownLatch的区别/","text":"1. CyclicBarrier和CountDownLatch的区别 CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。 CyclicBarrier还提供其他有用的方法，比如getNumberWaiting()方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。 2. 实例12345678910111213141516171819202122232425262728293031import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * Created by cyrstal on 17/1/2 20:12. * CyclicBarrier实例3 * @Version 1.0 * @Author crystal */public class CyclicBarrierTest3 &#123; static CyclicBarrier cyclicBarrier = new CyclicBarrier(2); public static void main(String[] args) &#123; Thread thread = new Thread(() -&gt; &#123; try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); thread.start(); thread.interrupt(); try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; System.out.println(cyclicBarrier.isBroken()); &#125; &#125;&#125; 输出结果: true","tags":[{"name":"CyclicBarrier和CountDownLatch的区别","slug":"CyclicBarrier和CountDownLatch的区别","permalink":"http://crystalxiaoou.github.io/tags/CyclicBarrier和CountDownLatch的区别/"}]},{"title":"CountDownLatch学习","date":"2017-01-02T11:36:36.000Z","path":"2017/01/02/CountDownLatch学习/","text":"1. 等待多线程完成的CountDownLatch CountDownLatch允许一个或多个线程等待其他线程完成操作。 应用场景: 我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多线程，每个线程解析一个sheet里的数据, 等到所有的sheet都解析完之后， 程序需要提示解析完成。在这个需求里，需要实现主线程等到所有线程完成sheet的解析操作，最简单的做法是使用join方法。 1.1 使用join()方法完成描述的场景123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Created by crystal on 17/1/2 18:21. * join 用于让当前执行线程等到join线程执行结束 * @Version 1.0 * @Author crystal */public class JoinCountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; // 匿名内部类 Thread parse1 = new Thread(()-&gt; &#123; System.out.println(\"parse1 finished\"); &#125;); Thread parse2 = new Thread(()-&gt; &#123; System.out.println(\"parse2 finished\"); &#125;); parse1.start(); parse2.start(); parse1.join(); parse2.join(); System.out.println(\"all parser finish\"); &#125; /** * Thread类里的join()方法 */ public final void join() throws InterruptedException &#123; join(0); &#125; public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125;&#125; join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。其中,wait(0)表示永远等待下去。join()代码片段: 123while(isAlive()) &#123; wait(0);&#125; 直到join线程中止后，线程的this.notifyAll()方法会被调用,调用的notifyAll()方法是在JVM里实现的。 1.2 使用CountDownLatch完成描述的场景123456789101112131415161718192021/** * Created by crystal on 17/1/2 18:35. * CountDownLatch的使用, 主线程等待一组线程执行完毕 * @Version 1.0 * @Author crystal */public class CountDownLatchTest &#123; static CountDownLatch countDownLatch = new CountDownLatch(2); public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; System.out.println(1); countDownLatch.countDown(); System.out.println(2); countDownLatch.countDown(); &#125;).start(); countDownLatch.await(); System.out.println(3); &#125;&#125; CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。 space 当我们调用CountDownLatch的countDown方法时，N就会减1， CountDownLatch的await()方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N点，可以是N个线程，也可以是1个线程的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。 space 如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await()方法–await(long time, TimeUnit unit), 这个方法等待指定的时间后，就会不再阻塞当前线程。join()也有类似的方法。 space 计数器必须大于等于0，只是等于0时，计数器就是0， 调用await()方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before另外一个线程调用await()方法。","tags":[{"name":"CountDownLatch","slug":"CountDownLatch","permalink":"http://crystalxiaoou.github.io/tags/CountDownLatch/"}]},{"title":"同步屏障CyclicBarrier","date":"2017-01-02T10:39:32.000Z","path":"2017/01/02/同步屏障CyclicBarrier/","text":"1. CyclicBarrier介绍 CyclicBarrier的字面意思是可循环使用(Cyclic)的屏障(Barrier)。 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 2. CyclicBarrier使用 CyclicBarrier默认的构造方法是CyclicBarrier(int parties）,其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉CyclicBarrier我已经到达屏障，然后当前线程被阻塞。 3. CyclicBarrier实例一12345678910111213141516171819public class CyclicBarrierTest &#123; static CyclicBarrier cyclicBarrier = new CyclicBarrier(2); public static void main(String[] args) &#123; new Thread(()-&gt; &#123; try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(1); &#125;).start(); try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(2); &#125;&#125; 因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出: 第一种输出:2 1 第二种输出:1 2 如果把new CyclicBarrier(2)改为new CyclicBarrier(3)， 则主线程和子线程会永远等待，因为没有第三个线程执行await()方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续。 4. CyclicBarrier实例二 CyclicBarrier 还提供了一个更高级的构造函数CyclicBarrier(int parties, Runnable barrier-Action), 用于在线程到达屏障时，优先执行barrierAction, 方便处理更复杂的业务场景。 1234567891011121314151617181920212223242526public class CyclicBarrierTest2 &#123; static CyclicBarrier cyclicBarrier = new CyclicBarrier(2, new A()); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(1); &#125;).start(); try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(2); &#125; static class A implements Runnable &#123; @Override public void run() &#123; System.out.println(3); &#125; &#125;&#125; 因为CyclicBarrier 设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完之后，才会继续执行主线程，然后输出2，所以代码执行后的输出一直为: 3 1 2 4.CyclicBarrier的应用场景 CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个excel 保存了用户所有银行流水，每个sheet保存一个帐号近一年的每笔流水，现在要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完后，得到每个sheet的日均银行流水，最后，再用barrier用这些线程的计算结果，计算出整个Excel的日均银行流水。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class BankWaterService implements Runnable &#123; /** * 创建4个屏障,处理完后执行当前类的run方法 */ private CyclicBarrier cyclicBarrier = new CyclicBarrier(4, this); /** * 假设只有4个sheet, 所以只启动4个线程 */ private Executor executor = Executors.newFixedThreadPool(4); private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;&gt;(); private void count() &#123; for (int i = 0; i &lt; 4; i++) &#123; executor.execute(() -&gt; &#123; // 计算当前sheet的银流数据， 计算代码省略 sheetBankWaterCount.put(Thread.currentThread().getName(), 1); // 银行流水计算完成，插入一个屏障 try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; &#125; &#125;); &#125; &#125; @Override public void run() &#123; int result = 0; // 汇总每个sheet计算出的结果 for (Map.Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet()) &#123; result += sheet.getValue(); &#125; // 将结果输出 sheetBankWaterCount.put(\"result\", result); System.out.println(result); &#125; public static void main(String[] args) &#123; BankWaterService bankWaterService = new BankWaterService(); bankWaterService.count(); &#125;&#125; 使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1, 再由BankWaterService线程汇总4个sheet计算出的结果，输出为: 4。","tags":[{"name":"CyclicBarrier","slug":"CyclicBarrier","permalink":"http://crystalxiaoou.github.io/tags/CyclicBarrier/"},{"name":"Java多线程","slug":"Java多线程","permalink":"http://crystalxiaoou.github.io/tags/Java多线程/"}]},{"title":"优化SQL的一般步骤","date":"2017-01-02T05:43:31.000Z","path":"2017/01/02/优化SQL的一般步骤/","text":"1. 通过show status 命令了解各种SQL的执行频率1.1 MySQL客户端连接成功后，通过show [session|global] status 命令可以提供服务器状态信息 1.2 在操作系统上，可以使用mysqladmin extended-status 命令获取这些消息。 1.3 show [session|global] status可以根据需要加上参数”session” 或者 “global” 来显示session级（当前连接) 的统计结果和global级（自数据库上次启动至今）的统计结果。 不写，则默认为session级。 1.4 下面的命令显示了当前session中所有统计参数的值 1.4.1 Com_xxx表示每个xxx语句的执行次数,我们通常比较关系的统计参数如下 字段 含义 Com_select 执行select操作的次数，一次查询只累加1 Com_insert 执行insert操作的次数，对于批量插入的INSERT操作，只累加一次 Com_update 执行update操作的次数 Com_delete 执行delete操作的次数 备注：上面这些参数对于所有存储引擎的表操作都会进行累计。 1.4.2 下面这几个参数只是针对InnoDB存储引擎的 字段 含义 Innodb_rows_read select查询返回的行数 Innodb_inserted 执行Insert操作插入的行数 Innodb_updated 执行Updated操作更新的行数 Innodb_deleted 执行Deleted操作删除的行数 备注： （1）通过以上几个参数，可以很容易了解当前数据库的应用是以插入为主还是以查询操作为主，以及各类SQL大致的执行比例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加 1.4.3 对于事务型的应用，通过Com_commit和Com_rollback可以了解事务提交和回滚的情况,对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题 1.4.4 了解数据库基本情况的几个参数 字段 含义 Connections 试图连接MySQL服务器的次数 Uptime 服务器工作时间 Slow_queries 慢查询的次数 2. 定位执行效率较低的SQL可以通过以下两种方式定位执行效率较低的SQL： 通过慢查询日志定位那些执行效率较低的SQL语句，用–log-slow-queries[=file_name]选项启动时，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。 慢查询日志在查询以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MYSQL在运行的线程，包括线程的状态、是否锁表等，可以实时地查看SQL的执行情况，同时对一些锁表操作进行优化。 3. 通过EXPLAIN分析低效SQL的执行计划3.1 查询到效率低的SQL后，可以通过EXPLAIN或者DESC命令获取MYSQL如何执行SELECT语句的信息,包括在SELECT语句执行过程中，表如何连接和连接的顺序 3.2 如果想查询2006年所有公司的销售额，需要管理sales表和company表，并且对moneys字段做求和(sum)操作，相应SQL的执行计划如下: 3.3 每个列的简单解析如下 字段 含义 备注 select_type 表示SELECT的类型，常见的取值有：1. SIMPLE(简单表，即不使用表连接或子查询)2. PRIMARY(主查询，即外部的查询)3. UNION (UNION中的第二个或者后面的查询语句)4. SUBQUERY(子查询中的第一个SELECT) 这里只列出主要的 table 输出结果集的表 type 表示表的连接类型,性能由好到差的类型为:1. system(表中仅有一行，即常量表) 2. const(单表中最多有一个匹配行，例如primary key 或者 unique index) 3. eq_ref(对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用primary key 或者unique index) 4. ref(与eq_ref类似，区别是多表连接中使用普通的索引) 5. ref_or_null(与ref类似，区别在于条件中包含对NULL的查询) 6. index_merge(索引合并优化) 7. unique_subquery(in 的后面是一个查询主键字段的子查询) 8. index_subquery(与unique_subquery类似，区别在于in的后面是查询非唯一索引字段的子查询) 9. range(单表中的范围查询) 10. index(对于前面的每一行，都通过索引查询来得到数据) 11. all(对于前面的每一行，都通过全表扫描来得到数据) possible_keys 表示查询时，可能使用的索引 key 表示实际使用的索引 key_len 索引字段的长度 rows 扫描行的数量 Extra 执行情况的说明和描述 4. 确定问题，并采取相应的优化措施4.1 经过以上3个步骤的分析，基本就可以确认问题出现的原因。此时，可以根据情况采取相应的措施，进行优化提高执行的效率 4.2 在上面的例子中，已经可以确认是对a表的全表扫描导致效率的不理想，那么对a表的year字段创建索引，具体如下: 4.3 重新查看执行计划，如下: 备注: 可以发现建立索引后，对a表的扫描行数明显减少(从1000行减少到1行)， 可见索引可以大大提高数据库访问速度，尤其在表很庞大的时候，这种优势更加明显。","tags":[{"name":"SQL优化","slug":"SQL优化","permalink":"http://crystalxiaoou.github.io/tags/SQL优化/"},{"name":"MYSQL服务器状态","slug":"MYSQL服务器状态","permalink":"http://crystalxiaoou.github.io/tags/MYSQL服务器状态/"},{"name":"explain","slug":"explain","permalink":"http://crystalxiaoou.github.io/tags/explain/"},{"name":"sql执行计划","slug":"sql执行计划","permalink":"http://crystalxiaoou.github.io/tags/sql执行计划/"},{"name":"慢查询","slug":"慢查询","permalink":"http://crystalxiaoou.github.io/tags/慢查询/"}]},{"title":"Swagger学习(一)","date":"2016-12-30T08:20:33.000Z","path":"2016/12/30/Swagger学习-一/","text":"1. API接口文档自动化生成工具","tags":[{"name":"Swagger","slug":"Swagger","permalink":"http://crystalxiaoou.github.io/tags/Swagger/"},{"name":"API接口文档自动化生成工具推荐","slug":"API接口文档自动化生成工具推荐","permalink":"http://crystalxiaoou.github.io/tags/API接口文档自动化生成工具推荐/"}]},{"title":"JNDI基础概念","date":"2016-12-23T13:50:20.000Z","path":"2016/12/23/JNDI基础概念/","text":"1. 命名服务的相关概念：1.1 Naming Service 命名服务命名服务将名称和对象进行关联，提供通过名称找到对象的操作。例如：DNS系统将计算机名和IP地址进行关联。文件系统将文件名和文件句柄进行关联等等。 1.2 Name 名称要在命名系统中查找对象，需要提供对象的名称。对象的名称是用来标识该对象的易于人理解的名称。例如：文件系统用文件名来标识文件对象。DNS系统用机器名来表示IP地址。 1.3 Naming Convention 命名规范`一个命名系统中的所有名称必须遵循的语法规则称为命名规范。例如：UNIX文件系统的命名规范要求文件名是一个相对于根目录的路径，路径中的每一部分以/分隔。如：/usr/bin。 1.4 Binding 绑定一个名称和一个对象的关联称为一个绑定。例如：文件系统中，文件名绑定到文件。DNS系统中，机器名绑定到IP地址。 1.5 Reference 引用在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。 1.6 Address 地址引用通常用一个或多个地址(通信端口)来表示。 1.7 Context 上下文一个上下文是一系列名称和对象的绑定的集合。每个上下文都有与之关联的命名规范。一个上下文通常提供一个lookup操作来返回对象，也可能提供绑定，解除绑定，列举绑定名等操作。一个上下文中的名称可以绑定到一个具有相同命名规范的上下文中，称之为子上下文(subcontext)。例如：在文件系统中，/usr是一个Context，/usr/bin是usr的subcontext。 1.8 Naming System 命名系统一个相同类型的Context的集合。一个命名系统向客户提供命名服务来执行命名相关的操作。如DNS系统，LDAP系统等。 1.9 Namespace 名称空间一个命名系统的所有名称的集合。例如：文件系统中的名称空间是组成该文件系统的所有文件和目录的名称。 Atomic Name/Compound Name/Composite NameAtomic Name 原子名称，是一个简单的基本的名称。Compound Name 混合名称，是由多个原子名称一起构成的名称。Composite Name 复合名称，是跨越多个命名系统的名称。例如：一个名称可能是uid=admin,ou=cms,dc=foobar,dc=com/user/bin/jndi，其中，uid=admin,ou=cms,dc=foobar,dc=com/user/bin/jndi是一个复合名称，跨越了两个命名系统LDAP和文件系统，uid=admin,ou=cms,dc=foobar,dc=com和/user/bin/jndi是两个混合名称，uid=admin、ou=cms、dc=foobar分别是原子名称。 2. 目录服务的相关概念2.1 Directory Service 目录服务目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。目录服务中的对象称之为目录对象。目录服务提供创建、添加、删除目录对象以及修改目录对象属性等操作。 2.2 Attribute 属性一个目录对象可以包含属性。一个属性具有一个属性标识符和一系列属性值。例如：一个打印机对象可以包含速度、分辨率等属性。分辨率的属性标识是resolution，属性值可能是300dpi,600dpi等等。 2.3 Search Filter 查找过滤器目录服务除了通过名称查找对象的操作，通常还提供通过目录对象的属性来查找对象的操作。这种的查找一般通过规定的表达式来表示，称之为查找过滤器。","tags":[{"name":"JNDI","slug":"JNDI","permalink":"http://crystalxiaoou.github.io/tags/JNDI/"},{"name":"命名服务","slug":"命名服务","permalink":"http://crystalxiaoou.github.io/tags/命名服务/"},{"name":"目录服务","slug":"目录服务","permalink":"http://crystalxiaoou.github.io/tags/目录服务/"}]},{"title":"Spring对J2EE服务的继承和支持之Spring框架内的JNDI支持","date":"2016-12-22T14:17:31.000Z","path":"2016/12/22/Spring集成J2EE/","text":"1.介绍 &nbsp;&nbsp;&nbsp;&nbsp;Spring框架通过近乎一致的方式对各种J2EE服务API的使用进行了合适的封装，简化了我们的日常开发工作。 2.JNDI简单回顾 &nbsp;&nbsp;&nbsp;&nbsp;JNDI(Java Naming and Directory Interfare, Java命名与目录接口)，其主要目的是为了统一各种命名与目录服务(naming service/directory service)的访问接口。整个JNDI的架构由API和SPI(Service Provider Interface)两部分组成，如下图所示。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JNDI API主要公开给引用程序使用，她为Java应用程序访问各种命名与目录服务提供了统一的接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JNDI SPI主要公开给具体命名或目录服务商(Vendor)使用,它为各种具体的命名和目录服务产品提供了一个扩展层。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在JavaEE平台上,JNDI更多的为资源的访问或部署提供了一个隔离层。 JNDI的常见应用场景:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) JMS需要通过JNDI获取ConnectionFactory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2) EJB需要通过JNDI获取Home接口的引用 3.Spring框架内访问JNDI的基石-JndiTemplate4.测试","tags":[{"name":"JNDI","slug":"JNDI","permalink":"http://crystalxiaoou.github.io/tags/JNDI/"},{"name":"Spring","slug":"Spring","permalink":"http://crystalxiaoou.github.io/tags/Spring/"}]},{"title":"资管CR测试","date":"2016-12-20T16:13:31.000Z","path":"2016/12/21/资管v0.3 接口端CR记录/","text":"资管V0.3接口端CR记录瑞志 @AutoWired 注入时最好都用接口进行注入 (同一个父类时，加@Qualifier指明 注入哪个类) 用yarn写 配置文件可读性会更好&gt; 一个项目最好一个流程包（AMS一个， ABS一个） 把一个流程做成一个对象，把属性放在里面会更好(包ID, processID 等属性) BMP 审核的代码还可以再抽象点，通过状态机流转简化流程 审核希望以后做成基础服务，瑞志配合， AMS、ABS 公用 王磊 不用的代码直接删掉(涉及到审核的部分) 字段校验失败，通知前端具体哪个字段？抛出一个异常 or 返回通知消息 抛出异常时需要把异常堆栈打出来 request.getUserName() 这句话 可以使用一个UserHandler， 把username 在登录时放到ThreadLocal里， 之后直接get即可 事务跨了远程调用最好使用Executor异步执行TransactionCallBack进行回调去处理事务 不要使用e.printStackTrace() 打印异常栈，最好使用logger.info(e); 记录到日志里 计划和产品是两个聚合根，最好分开单独处理（使用command）, 这里计划下的产品与产品无关系，可以一起处理 异常捕获后需要处理，或者直接不捕获 把所有的表单请求字段拼接起来算一个md5值， 存在redis中，短时间有两条的话， 只处理一条， 前后端都需要处理 幂等性，交易， 多次请求，只有一次回复，前端添加一次请求，如果一定时间没有返回，就再发一次，直到成功。 初始化一个StringBuilider时，直接new StringBuidler即可 时间格式化使用一个时间工具类， 不要直接写在代码里 产品价格生效 和 未生效 公有的代码可以提出来，不要重复 字段命名在不同的类中最好统一一下 枚举直接通过==判断，不用取出code,再用equals判断 产品价格参数校验失败直接抛出参数校验失败的异常 收益率参数的校验还需要补充下 单测需要补充下，主要分支需要覆盖到， 收益率生效，未生效 房杰 FeeMode 直接switch , 不用getCode出来在Switch 枚举直接判断，不用getCode 没用到的变量直接删掉 request.getData().validate() 提出来 errMsg 做成枚举或者 ErrCode 查出来再更新， 可以在loadById时加悲观锁 查当前审核人的代码 可以抽出来，实现一个接口或者公共类，查询审核人的代码公用 保存产品费用后端需要做校验 删除产品费用是，关联的产品费用进行批量查询 产品费用操作加事务 验证失败直接抛出异常即可 new Money (0) 改为 Money.ZERO 一个方法参数里调用另一个方法时，把另一个方法抽出来 loadById 的时候改成悲观锁, update 的时候再释放掉 需要加个事务， 避免并发 version 乐观锁, 没怎么用， 对性能要求较高，一致性要求较低时可以用 跑批的时候 可以用乐观锁， 多条机器可以并行的跑时可以用 用jdk8 里的LocalDateTime代替jodaTime 张波 与前面三位差不多","tags":[]},{"title":"数据库默认隔离级别","date":"2016-12-20T15:33:40.000Z","path":"2016/12/20/DB-ISOLATION/","text":"1.InnoDB默认是可重复读的（REPEATABLE READ）2.你可以在命令行用–transaction-isolation选项，或在选项文件里，为所有连接设置默认隔离级别。 在my.cfg文件的[mysqld]节里类似如下设置该选项：= &#123;READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE&#125;123```3.用户可以用SET TRANSACTION语句改变单个会话或者所有新进连接的隔离级别```SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125; 4.用下列语句查询全局和会话事务隔离级别@@global.tx_isolation;12SELECT @@session.tx_isolation;SELECT @@tx_isolation; Oracle等多数数据库默认都是读已提交(Read Committed)","tags":[]},{"title":"Hello World","date":"2016-11-29T08:57:15.000Z","path":"2016/11/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"My First Blog","date":"2015-07-29T23:56:29.000Z","path":"2015/07/30/MyFirstBlog/","text":"在Java中如何高效的判断数组中是否包含某个元素代码1ArrayUtils.contains();","tags":[{"name":"hexo","slug":"hexo","permalink":"http://crystalxiaoou.github.io/tags/hexo/"},{"name":"apache commons","slug":"apache-commons","permalink":"http://crystalxiaoou.github.io/tags/apache-commons/"}]}]