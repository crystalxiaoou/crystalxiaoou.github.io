[{"title":"JNDI基础概念","date":"2016-12-23T13:50:20.000Z","path":"2016/12/23/JNDI基础概念/","text":"1. 命名服务的相关概念：1.1 Naming Service 命名服务命名服务将名称和对象进行关联，提供通过名称找到对象的操作。例如：DNS系统将计算机名和IP地址进行关联。文件系统将文件名和文件句柄进行关联等等。 1.2 Name 名称要在命名系统中查找对象，需要提供对象的名称。对象的名称是用来标识该对象的易于人理解的名称。例如：文件系统用文件名来标识文件对象。DNS系统用机器名来表示IP地址。 1.3 Naming Convention 命名规范`一个命名系统中的所有名称必须遵循的语法规则称为命名规范。例如：UNIX文件系统的命名规范要求文件名是一个相对于根目录的路径，路径中的每一部分以/分隔。如：/usr/bin。 1.4 Binding 绑定一个名称和一个对象的关联称为一个绑定。例如：文件系统中，文件名绑定到文件。DNS系统中，机器名绑定到IP地址。 1.5 Reference 引用在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。 1.6 Address 地址引用通常用一个或多个地址(通信端口)来表示。 1.7 Context 上下文一个上下文是一系列名称和对象的绑定的集合。每个上下文都有与之关联的命名规范。一个上下文通常提供一个lookup操作来返回对象，也可能提供绑定，解除绑定，列举绑定名等操作。一个上下文中的名称可以绑定到一个具有相同命名规范的上下文中，称之为子上下文(subcontext)。例如：在文件系统中，/usr是一个Context，/usr/bin是usr的subcontext。 1.8 Naming System 命名系统一个相同类型的Context的集合。一个命名系统向客户提供命名服务来执行命名相关的操作。如DNS系统，LDAP系统等。 1.9 Namespace 名称空间一个命名系统的所有名称的集合。例如：文件系统中的名称空间是组成该文件系统的所有文件和目录的名称。 Atomic Name/Compound Name/Composite NameAtomic Name 原子名称，是一个简单的基本的名称。Compound Name 混合名称，是由多个原子名称一起构成的名称。Composite Name 复合名称，是跨越多个命名系统的名称。例如：一个名称可能是uid=admin,ou=cms,dc=foobar,dc=com/user/bin/jndi，其中，uid=admin,ou=cms,dc=foobar,dc=com/user/bin/jndi是一个复合名称，跨越了两个命名系统LDAP和文件系统，uid=admin,ou=cms,dc=foobar,dc=com和/user/bin/jndi是两个混合名称，uid=admin、ou=cms、dc=foobar分别是原子名称。 2. 目录服务的相关概念2.1 Directory Service 目录服务目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。目录服务中的对象称之为目录对象。目录服务提供创建、添加、删除目录对象以及修改目录对象属性等操作。 2.2 Attribute 属性一个目录对象可以包含属性。一个属性具有一个属性标识符和一系列属性值。例如：一个打印机对象可以包含速度、分辨率等属性。分辨率的属性标识是resolution，属性值可能是300dpi,600dpi等等。 2.3 Search Filter 查找过滤器目录服务除了通过名称查找对象的操作，通常还提供通过目录对象的属性来查找对象的操作。这种的查找一般通过规定的表达式来表示，称之为查找过滤器。","tags":[{"name":"JNDI","slug":"JNDI","permalink":"http://crystalxiaoou.github.io/tags/JNDI/"},{"name":"命名服务","slug":"命名服务","permalink":"http://crystalxiaoou.github.io/tags/命名服务/"},{"name":"目录服务","slug":"目录服务","permalink":"http://crystalxiaoou.github.io/tags/目录服务/"}]},{"title":"Spring对J2EE服务的继承和支持之Spring框架内的JNDI支持","date":"2016-12-22T14:17:31.000Z","path":"2016/12/22/Spring集成J2EE/","text":"1.介绍 &nbsp;&nbsp;&nbsp;&nbsp;Spring框架通过近乎一致的方式对各种J2EE服务API的使用进行了合适的封装，简化了我们的日常开发工作。 2.JNDI简单回顾 &nbsp;&nbsp;&nbsp;&nbsp;JNDI(Java Naming and Directory Interfare, Java命名与目录接口)，其主要目的是为了统一各种命名与目录服务(naming service/directory service)的访问接口。整个JNDI的架构由API和SPI(Service Provider Interface)两部分组成，如下图所示。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JNDI API主要公开给引用程序使用，她为Java应用程序访问各种命名与目录服务提供了统一的接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JNDI SPI主要公开给具体命名或目录服务商(Vendor)使用,它为各种具体的命名和目录服务产品提供了一个扩展层。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在JavaEE平台上,JNDI更多的为资源的访问或部署提供了一个隔离层。 JNDI的常见应用场景:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) JMS需要通过JNDI获取ConnectionFactory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2) EJB需要通过JNDI获取Home接口的引用 3.Spring框架内访问JNDI的基石-JndiTemplate4.测试","tags":[{"name":"JNDI","slug":"JNDI","permalink":"http://crystalxiaoou.github.io/tags/JNDI/"},{"name":"Spring","slug":"Spring","permalink":"http://crystalxiaoou.github.io/tags/Spring/"}]},{"title":"资管CR测试","date":"2016-12-20T16:13:31.000Z","path":"2016/12/21/资管v0.3 接口端CR记录/","text":"资管V0.3接口端CR记录瑞志 @AutoWired 注入时最好都用接口进行注入 (同一个父类时，加@Qualifier指明 注入哪个类) 用yarn写 配置文件可读性会更好&gt; 一个项目最好一个流程包（AMS一个， ABS一个） 把一个流程做成一个对象，把属性放在里面会更好(包ID, processID 等属性) BMP 审核的代码还可以再抽象点，通过状态机流转简化流程 审核希望以后做成基础服务，瑞志配合， AMS、ABS 公用 王磊 不用的代码直接删掉(涉及到审核的部分) 字段校验失败，通知前端具体哪个字段？抛出一个异常 or 返回通知消息 抛出异常时需要把异常堆栈打出来 request.getUserName() 这句话 可以使用一个UserHandler， 把username 在登录时放到ThreadLocal里， 之后直接get即可 事务跨了远程调用最好使用Executor异步执行TransactionCallBack进行回调去处理事务 不要使用e.printStackTrace() 打印异常栈，最好使用logger.info(e); 记录到日志里 计划和产品是两个聚合根，最好分开单独处理（使用command）, 这里计划下的产品与产品无关系，可以一起处理 异常捕获后需要处理，或者直接不捕获 把所有的表单请求字段拼接起来算一个md5值， 存在redis中，短时间有两条的话， 只处理一条， 前后端都需要处理 幂等性，交易， 多次请求，只有一次回复，前端添加一次请求，如果一定时间没有返回，就再发一次，直到成功。 初始化一个StringBuilider时，直接new StringBuidler即可 时间格式化使用一个时间工具类， 不要直接写在代码里 产品价格生效 和 未生效 公有的代码可以提出来，不要重复 字段命名在不同的类中最好统一一下 枚举直接通过==判断，不用取出code,再用equals判断 产品价格参数校验失败直接抛出参数校验失败的异常 收益率参数的校验还需要补充下 单测需要补充下，主要分支需要覆盖到， 收益率生效，未生效 房杰 FeeMode 直接switch , 不用getCode出来在Switch 枚举直接判断，不用getCode 没用到的变量直接删掉 request.getData().validate() 提出来 errMsg 做成枚举或者 ErrCode 查出来再更新， 可以在loadById时加悲观锁 查当前审核人的代码 可以抽出来，实现一个接口或者公共类，查询审核人的代码公用 保存产品费用后端需要做校验 删除产品费用是，关联的产品费用进行批量查询 产品费用操作加事务 验证失败直接抛出异常即可 new Money (0) 改为 Money.ZERO 一个方法参数里调用另一个方法时，把另一个方法抽出来 loadById 的时候改成悲观锁, update 的时候再释放掉 需要加个事务， 避免并发 version 乐观锁, 没怎么用， 对性能要求较高，一致性要求较低时可以用 跑批的时候 可以用乐观锁， 多条机器可以并行的跑时可以用 用jdk8 里的LocalDateTime代替jodaTime 张波 与前面三位差不多","tags":[]},{"title":"数据库默认隔离级别","date":"2016-12-20T15:33:40.000Z","path":"2016/12/20/DB-ISOLATION/","text":"1.InnoDB默认是可重复读的（REPEATABLE READ）2.你可以在命令行用–transaction-isolation选项，或在选项文件里，为所有连接设置默认隔离级别。 在my.cfg文件的[mysqld]节里类似如下设置该选项：= &#123;READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE&#125;123```3.用户可以用SET TRANSACTION语句改变单个会话或者所有新进连接的隔离级别```SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125; 4.用下列语句查询全局和会话事务隔离级别@@global.tx_isolation;12SELECT @@session.tx_isolation;SELECT @@tx_isolation; Oracle等多数数据库默认都是读已提交(Read Committed)","tags":[]},{"title":"Hello World","date":"2016-11-29T08:57:15.000Z","path":"2016/11/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"My First Blog","date":"2015-07-29T23:56:29.000Z","path":"2015/07/30/MyFirstBlog/","text":"在Java中如何高效的判断数组中是否包含某个元素代码1ArrayUtils.contains();","tags":[{"name":"hexo","slug":"hexo","permalink":"http://crystalxiaoou.github.io/tags/hexo/"},{"name":"apache commons","slug":"apache-commons","permalink":"http://crystalxiaoou.github.io/tags/apache-commons/"}]}]