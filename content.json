[{"title":"Redis 命令学习","date":"2017-01-04T15:57:54.000Z","path":"2017/01/04/Redis-命令学习/","text":"1. 在数据库中创建一个值为String对象的键值对1redis&gt; SET msg &quot;hello world&quot; 键值对的键是一个字符串对象(对象底层实现是一个保存字符串”msg”的SDS) 键值对的值也是一个字符串对象 2. 在数据库中创建一个值为列表的键值对1redis&gt; RPUSH fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot; 键值对的键是一个字符串对象(对象底层实现是一个保存字符串”msg”的SDS)键值对的值是一个列表对象，列表对象包含三个字符串对象","tags":[{"name":"Redis命令","slug":"Redis命令","permalink":"http://crystalxiaoou.github.io/tags/Redis命令/"}]},{"title":"重股交长度对照","date":"2017-01-04T07:00:00.000Z","path":"2017/01/04/重股交字段长度不OK 统计/","text":"重股交字段长度不OK 统计1. 所有文件中的金额、份额都没有写精确到几位小数2. 产品全称，产品简称长度比资管的小 来源 长度不OK字段 对应长度 Sale 产品行情文件 产品名称 40 资管DB产品表 项目名称 300 重股交 产品明细文件 产品全称，产品简称 20 3. 客户销售明细 里的客户姓名，客户全称字段长度比资管小 来源 长度不OK字段 对应长度 Sale 开户申请 客户名称 100 资管DB开户表 客户名称 100 重股交 客户销售明细 客户姓名，客户全称 64 4. 还款试算表 客户姓名同35. 产品托管表 客户姓名同3","tags":[{"name":"项目","slug":"项目","permalink":"http://crystalxiaoou.github.io/tags/项目/"}]},{"title":"CyclicBarrier和CountDownLatch的区别","date":"2017-01-02T12:11:49.000Z","path":"2017/01/02/CyclicBarrier和CountDownLatch的区别/","text":"1. CyclicBarrier和CountDownLatch的区别 CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。 CyclicBarrier还提供其他有用的方法，比如getNumberWaiting()方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。 2. 实例12345678910111213141516171819202122232425262728293031import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * Created by cyrstal on 17/1/2 20:12. * CyclicBarrier实例3 * @Version 1.0 * @Author crystal */public class CyclicBarrierTest3 &#123; static CyclicBarrier cyclicBarrier = new CyclicBarrier(2); public static void main(String[] args) &#123; Thread thread = new Thread(() -&gt; &#123; try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); thread.start(); thread.interrupt(); try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; System.out.println(cyclicBarrier.isBroken()); &#125; &#125;&#125; 输出结果: true","tags":[{"name":"CyclicBarrier和CountDownLatch的区别","slug":"CyclicBarrier和CountDownLatch的区别","permalink":"http://crystalxiaoou.github.io/tags/CyclicBarrier和CountDownLatch的区别/"}]},{"title":"CountDownLatch学习","date":"2017-01-02T11:36:36.000Z","path":"2017/01/02/CountDownLatch学习/","text":"1. 等待多线程完成的CountDownLatch CountDownLatch允许一个或多个线程等待其他线程完成操作。 应用场景: 我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多线程，每个线程解析一个sheet里的数据, 等到所有的sheet都解析完之后， 程序需要提示解析完成。在这个需求里，需要实现主线程等到所有线程完成sheet的解析操作，最简单的做法是使用join方法。 1.1 使用join()方法完成描述的场景123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Created by crystal on 17/1/2 18:21. * join 用于让当前执行线程等到join线程执行结束 * @Version 1.0 * @Author crystal */public class JoinCountDownLatchTest &#123; public static void main(String[] args) throws InterruptedException &#123; // 匿名内部类 Thread parse1 = new Thread(()-&gt; &#123; System.out.println(\"parse1 finished\"); &#125;); Thread parse2 = new Thread(()-&gt; &#123; System.out.println(\"parse2 finished\"); &#125;); parse1.start(); parse2.start(); parse1.join(); parse2.join(); System.out.println(\"all parser finish\"); &#125; /** * Thread类里的join()方法 */ public final void join() throws InterruptedException &#123; join(0); &#125; public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125;&#125; join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。其中,wait(0)表示永远等待下去。join()代码片段: 123while(isAlive()) &#123; wait(0);&#125; 直到join线程中止后，线程的this.notifyAll()方法会被调用,调用的notifyAll()方法是在JVM里实现的。 1.2 使用CountDownLatch完成描述的场景123456789101112131415161718192021/** * Created by crystal on 17/1/2 18:35. * CountDownLatch的使用, 主线程等待一组线程执行完毕 * @Version 1.0 * @Author crystal */public class CountDownLatchTest &#123; static CountDownLatch countDownLatch = new CountDownLatch(2); public static void main(String[] args) throws InterruptedException &#123; new Thread(() -&gt; &#123; System.out.println(1); countDownLatch.countDown(); System.out.println(2); countDownLatch.countDown(); &#125;).start(); countDownLatch.await(); System.out.println(3); &#125;&#125; CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。 space 当我们调用CountDownLatch的countDown方法时，N就会减1， CountDownLatch的await()方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N点，可以是N个线程，也可以是1个线程的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。 space 如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await()方法–await(long time, TimeUnit unit), 这个方法等待指定的时间后，就会不再阻塞当前线程。join()也有类似的方法。 space 计数器必须大于等于0，只是等于0时，计数器就是0， 调用await()方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before另外一个线程调用await()方法。","tags":[{"name":"CountDownLatch","slug":"CountDownLatch","permalink":"http://crystalxiaoou.github.io/tags/CountDownLatch/"}]},{"title":"同步屏障CyclicBarrier","date":"2017-01-02T10:39:32.000Z","path":"2017/01/02/同步屏障CyclicBarrier/","text":"1. CyclicBarrier介绍 CyclicBarrier的字面意思是可循环使用(Cyclic)的屏障(Barrier)。 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 2. CyclicBarrier使用 CyclicBarrier默认的构造方法是CyclicBarrier(int parties）,其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉CyclicBarrier我已经到达屏障，然后当前线程被阻塞。 3. CyclicBarrier实例一12345678910111213141516171819public class CyclicBarrierTest &#123; static CyclicBarrier cyclicBarrier = new CyclicBarrier(2); public static void main(String[] args) &#123; new Thread(()-&gt; &#123; try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(1); &#125;).start(); try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(2); &#125;&#125; 因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出: 第一种输出:2 1 第二种输出:1 2 如果把new CyclicBarrier(2)改为new CyclicBarrier(3)， 则主线程和子线程会永远等待，因为没有第三个线程执行await()方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续。 4. CyclicBarrier实例二 CyclicBarrier 还提供了一个更高级的构造函数CyclicBarrier(int parties, Runnable barrier-Action), 用于在线程到达屏障时，优先执行barrierAction, 方便处理更复杂的业务场景。 1234567891011121314151617181920212223242526public class CyclicBarrierTest2 &#123; static CyclicBarrier cyclicBarrier = new CyclicBarrier(2, new A()); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(1); &#125;).start(); try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; &#125; System.out.println(2); &#125; static class A implements Runnable &#123; @Override public void run() &#123; System.out.println(3); &#125; &#125;&#125; 因为CyclicBarrier 设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A都执行完之后，才会继续执行主线程，然后输出2，所以代码执行后的输出一直为: 3 1 2 4.CyclicBarrier的应用场景 CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个excel 保存了用户所有银行流水，每个sheet保存一个帐号近一年的每笔流水，现在要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完后，得到每个sheet的日均银行流水，最后，再用barrier用这些线程的计算结果，计算出整个Excel的日均银行流水。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class BankWaterService implements Runnable &#123; /** * 创建4个屏障,处理完后执行当前类的run方法 */ private CyclicBarrier cyclicBarrier = new CyclicBarrier(4, this); /** * 假设只有4个sheet, 所以只启动4个线程 */ private Executor executor = Executors.newFixedThreadPool(4); private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;&gt;(); private void count() &#123; for (int i = 0; i &lt; 4; i++) &#123; executor.execute(() -&gt; &#123; // 计算当前sheet的银流数据， 计算代码省略 sheetBankWaterCount.put(Thread.currentThread().getName(), 1); // 银行流水计算完成，插入一个屏障 try &#123; cyclicBarrier.await(); &#125; catch (Exception e) &#123; &#125; &#125;); &#125; &#125; @Override public void run() &#123; int result = 0; // 汇总每个sheet计算出的结果 for (Map.Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet()) &#123; result += sheet.getValue(); &#125; // 将结果输出 sheetBankWaterCount.put(\"result\", result); System.out.println(result); &#125; public static void main(String[] args) &#123; BankWaterService bankWaterService = new BankWaterService(); bankWaterService.count(); &#125;&#125; 使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1, 再由BankWaterService线程汇总4个sheet计算出的结果，输出为: 4。","tags":[{"name":"CyclicBarrier","slug":"CyclicBarrier","permalink":"http://crystalxiaoou.github.io/tags/CyclicBarrier/"},{"name":"Java多线程","slug":"Java多线程","permalink":"http://crystalxiaoou.github.io/tags/Java多线程/"}]},{"title":"优化SQL的一般步骤","date":"2017-01-02T05:43:31.000Z","path":"2017/01/02/优化SQL的一般步骤/","text":"1. 通过show status 命令了解各种SQL的执行频率1.1 MySQL客户端连接成功后，通过show [session|global] status 命令可以提供服务器状态信息 1.2 在操作系统上，可以使用mysqladmin extended-status 命令获取这些消息。 1.3 show [session|global] status可以根据需要加上参数”session” 或者 “global” 来显示session级（当前连接) 的统计结果和global级（自数据库上次启动至今）的统计结果。 不写，则默认为session级。 1.4 下面的命令显示了当前session中所有统计参数的值 1.4.1 Com_xxx表示每个xxx语句的执行次数,我们通常比较关系的统计参数如下 字段 含义 Com_select 执行select操作的次数，一次查询只累加1 Com_insert 执行insert操作的次数，对于批量插入的INSERT操作，只累加一次 Com_update 执行update操作的次数 Com_delete 执行delete操作的次数 备注：上面这些参数对于所有存储引擎的表操作都会进行累计。 1.4.2 下面这几个参数只是针对InnoDB存储引擎的 字段 含义 Innodb_rows_read select查询返回的行数 Innodb_inserted 执行Insert操作插入的行数 Innodb_updated 执行Updated操作更新的行数 Innodb_deleted 执行Deleted操作删除的行数 备注： （1）通过以上几个参数，可以很容易了解当前数据库的应用是以插入为主还是以查询操作为主，以及各类SQL大致的执行比例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （2）对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加 1.4.3 对于事务型的应用，通过Com_commit和Com_rollback可以了解事务提交和回滚的情况,对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题 1.4.4 了解数据库基本情况的几个参数 字段 含义 Connections 试图连接MySQL服务器的次数 Uptime 服务器工作时间 Slow_queries 慢查询的次数 2. 定位执行效率较低的SQL可以通过以下两种方式定位执行效率较低的SQL： 通过慢查询日志定位那些执行效率较低的SQL语句，用–log-slow-queries[=file_name]选项启动时，mysqld写一个包含所有执行时间超过long_query_time秒的SQL语句的日志文件。 慢查询日志在查询以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MYSQL在运行的线程，包括线程的状态、是否锁表等，可以实时地查看SQL的执行情况，同时对一些锁表操作进行优化。 3. 通过EXPLAIN分析低效SQL的执行计划3.1 查询到效率低的SQL后，可以通过EXPLAIN或者DESC命令获取MYSQL如何执行SELECT语句的信息,包括在SELECT语句执行过程中，表如何连接和连接的顺序 3.2 如果想查询2006年所有公司的销售额，需要管理sales表和company表，并且对moneys字段做求和(sum)操作，相应SQL的执行计划如下: 3.3 每个列的简单解析如下 字段 含义 备注 select_type 表示SELECT的类型，常见的取值有：1. SIMPLE(简单表，即不使用表连接或子查询)2. PRIMARY(主查询，即外部的查询)3. UNION (UNION中的第二个或者后面的查询语句)4. SUBQUERY(子查询中的第一个SELECT) 这里只列出主要的 table 输出结果集的表 type 表示表的连接类型,性能由好到差的类型为:1. system(表中仅有一行，即常量表) 2. const(单表中最多有一个匹配行，例如primary key 或者 unique index) 3. eq_ref(对于前面的每一行，在此表中只查询一条记录，简单来说，就是多表连接中使用primary key 或者unique index) 4. ref(与eq_ref类似，区别是多表连接中使用普通的索引) 5. ref_or_null(与ref类似，区别在于条件中包含对NULL的查询) 6. index_merge(索引合并优化) 7. unique_subquery(in 的后面是一个查询主键字段的子查询) 8. index_subquery(与unique_subquery类似，区别在于in的后面是查询非唯一索引字段的子查询) 9. range(单表中的范围查询) 10. index(对于前面的每一行，都通过索引查询来得到数据) 11. all(对于前面的每一行，都通过全表扫描来得到数据) possible_keys 表示查询时，可能使用的索引 key 表示实际使用的索引 key_len 索引字段的长度 rows 扫描行的数量 Extra 执行情况的说明和描述 4. 确定问题，并采取相应的优化措施4.1 经过以上3个步骤的分析，基本就可以确认问题出现的原因。此时，可以根据情况采取相应的措施，进行优化提高执行的效率 4.2 在上面的例子中，已经可以确认是对a表的全表扫描导致效率的不理想，那么对a表的year字段创建索引，具体如下: 4.3 重新查看执行计划，如下: 备注: 可以发现建立索引后，对a表的扫描行数明显减少(从1000行减少到1行)， 可见索引可以大大提高数据库访问速度，尤其在表很庞大的时候，这种优势更加明显。","tags":[{"name":"SQL优化","slug":"SQL优化","permalink":"http://crystalxiaoou.github.io/tags/SQL优化/"},{"name":"MYSQL服务器状态","slug":"MYSQL服务器状态","permalink":"http://crystalxiaoou.github.io/tags/MYSQL服务器状态/"},{"name":"explain","slug":"explain","permalink":"http://crystalxiaoou.github.io/tags/explain/"},{"name":"sql执行计划","slug":"sql执行计划","permalink":"http://crystalxiaoou.github.io/tags/sql执行计划/"},{"name":"慢查询","slug":"慢查询","permalink":"http://crystalxiaoou.github.io/tags/慢查询/"}]},{"title":"Swagger学习(一)","date":"2016-12-30T08:20:33.000Z","path":"2016/12/30/Swagger学习-一/","text":"1. API接口文档自动化生成工具","tags":[{"name":"Swagger","slug":"Swagger","permalink":"http://crystalxiaoou.github.io/tags/Swagger/"},{"name":"API接口文档自动化生成工具推荐","slug":"API接口文档自动化生成工具推荐","permalink":"http://crystalxiaoou.github.io/tags/API接口文档自动化生成工具推荐/"}]},{"title":"JNDI基础概念","date":"2016-12-23T13:50:20.000Z","path":"2016/12/23/JNDI基础概念/","text":"1. 命名服务的相关概念：1.1 Naming Service 命名服务命名服务将名称和对象进行关联，提供通过名称找到对象的操作。例如：DNS系统将计算机名和IP地址进行关联。文件系统将文件名和文件句柄进行关联等等。 1.2 Name 名称要在命名系统中查找对象，需要提供对象的名称。对象的名称是用来标识该对象的易于人理解的名称。例如：文件系统用文件名来标识文件对象。DNS系统用机器名来表示IP地址。 1.3 Naming Convention 命名规范`一个命名系统中的所有名称必须遵循的语法规则称为命名规范。例如：UNIX文件系统的命名规范要求文件名是一个相对于根目录的路径，路径中的每一部分以/分隔。如：/usr/bin。 1.4 Binding 绑定一个名称和一个对象的关联称为一个绑定。例如：文件系统中，文件名绑定到文件。DNS系统中，机器名绑定到IP地址。 1.5 Reference 引用在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。 1.6 Address 地址引用通常用一个或多个地址(通信端口)来表示。 1.7 Context 上下文一个上下文是一系列名称和对象的绑定的集合。每个上下文都有与之关联的命名规范。一个上下文通常提供一个lookup操作来返回对象，也可能提供绑定，解除绑定，列举绑定名等操作。一个上下文中的名称可以绑定到一个具有相同命名规范的上下文中，称之为子上下文(subcontext)。例如：在文件系统中，/usr是一个Context，/usr/bin是usr的subcontext。 1.8 Naming System 命名系统一个相同类型的Context的集合。一个命名系统向客户提供命名服务来执行命名相关的操作。如DNS系统，LDAP系统等。 1.9 Namespace 名称空间一个命名系统的所有名称的集合。例如：文件系统中的名称空间是组成该文件系统的所有文件和目录的名称。 Atomic Name/Compound Name/Composite NameAtomic Name 原子名称，是一个简单的基本的名称。Compound Name 混合名称，是由多个原子名称一起构成的名称。Composite Name 复合名称，是跨越多个命名系统的名称。例如：一个名称可能是uid=admin,ou=cms,dc=foobar,dc=com/user/bin/jndi，其中，uid=admin,ou=cms,dc=foobar,dc=com/user/bin/jndi是一个复合名称，跨越了两个命名系统LDAP和文件系统，uid=admin,ou=cms,dc=foobar,dc=com和/user/bin/jndi是两个混合名称，uid=admin、ou=cms、dc=foobar分别是原子名称。 2. 目录服务的相关概念2.1 Directory Service 目录服务目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。目录服务中的对象称之为目录对象。目录服务提供创建、添加、删除目录对象以及修改目录对象属性等操作。 2.2 Attribute 属性一个目录对象可以包含属性。一个属性具有一个属性标识符和一系列属性值。例如：一个打印机对象可以包含速度、分辨率等属性。分辨率的属性标识是resolution，属性值可能是300dpi,600dpi等等。 2.3 Search Filter 查找过滤器目录服务除了通过名称查找对象的操作，通常还提供通过目录对象的属性来查找对象的操作。这种的查找一般通过规定的表达式来表示，称之为查找过滤器。","tags":[{"name":"JNDI","slug":"JNDI","permalink":"http://crystalxiaoou.github.io/tags/JNDI/"},{"name":"命名服务","slug":"命名服务","permalink":"http://crystalxiaoou.github.io/tags/命名服务/"},{"name":"目录服务","slug":"目录服务","permalink":"http://crystalxiaoou.github.io/tags/目录服务/"}]},{"title":"Spring对J2EE服务的继承和支持之Spring框架内的JNDI支持","date":"2016-12-22T14:17:31.000Z","path":"2016/12/22/Spring集成J2EE/","text":"1.介绍 &nbsp;&nbsp;&nbsp;&nbsp;Spring框架通过近乎一致的方式对各种J2EE服务API的使用进行了合适的封装，简化了我们的日常开发工作。 2.JNDI简单回顾 &nbsp;&nbsp;&nbsp;&nbsp;JNDI(Java Naming and Directory Interfare, Java命名与目录接口)，其主要目的是为了统一各种命名与目录服务(naming service/directory service)的访问接口。整个JNDI的架构由API和SPI(Service Provider Interface)两部分组成，如下图所示。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JNDI API主要公开给引用程序使用，她为Java应用程序访问各种命名与目录服务提供了统一的接口。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JNDI SPI主要公开给具体命名或目录服务商(Vendor)使用,它为各种具体的命名和目录服务产品提供了一个扩展层。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在JavaEE平台上,JNDI更多的为资源的访问或部署提供了一个隔离层。 JNDI的常见应用场景:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) JMS需要通过JNDI获取ConnectionFactory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2) EJB需要通过JNDI获取Home接口的引用 3.Spring框架内访问JNDI的基石-JndiTemplate4.测试","tags":[{"name":"JNDI","slug":"JNDI","permalink":"http://crystalxiaoou.github.io/tags/JNDI/"},{"name":"Spring","slug":"Spring","permalink":"http://crystalxiaoou.github.io/tags/Spring/"}]},{"title":"资管CR测试","date":"2016-12-20T16:13:31.000Z","path":"2016/12/21/资管v0.3 接口端CR记录/","text":"资管V0.3接口端CR记录瑞志 @AutoWired 注入时最好都用接口进行注入 (同一个父类时，加@Qualifier指明 注入哪个类) 用yarn写 配置文件可读性会更好&gt; 一个项目最好一个流程包（AMS一个， ABS一个） 把一个流程做成一个对象，把属性放在里面会更好(包ID, processID 等属性) BMP 审核的代码还可以再抽象点，通过状态机流转简化流程 审核希望以后做成基础服务，瑞志配合， AMS、ABS 公用 王磊 不用的代码直接删掉(涉及到审核的部分) 字段校验失败，通知前端具体哪个字段？抛出一个异常 or 返回通知消息 抛出异常时需要把异常堆栈打出来 request.getUserName() 这句话 可以使用一个UserHandler， 把username 在登录时放到ThreadLocal里， 之后直接get即可 事务跨了远程调用最好使用Executor异步执行TransactionCallBack进行回调去处理事务 不要使用e.printStackTrace() 打印异常栈，最好使用logger.info(e); 记录到日志里 计划和产品是两个聚合根，最好分开单独处理（使用command）, 这里计划下的产品与产品无关系，可以一起处理 异常捕获后需要处理，或者直接不捕获 把所有的表单请求字段拼接起来算一个md5值， 存在redis中，短时间有两条的话， 只处理一条， 前后端都需要处理 幂等性，交易， 多次请求，只有一次回复，前端添加一次请求，如果一定时间没有返回，就再发一次，直到成功。 初始化一个StringBuilider时，直接new StringBuidler即可 时间格式化使用一个时间工具类， 不要直接写在代码里 产品价格生效 和 未生效 公有的代码可以提出来，不要重复 字段命名在不同的类中最好统一一下 枚举直接通过==判断，不用取出code,再用equals判断 产品价格参数校验失败直接抛出参数校验失败的异常 收益率参数的校验还需要补充下 单测需要补充下，主要分支需要覆盖到， 收益率生效，未生效 房杰 FeeMode 直接switch , 不用getCode出来在Switch 枚举直接判断，不用getCode 没用到的变量直接删掉 request.getData().validate() 提出来 errMsg 做成枚举或者 ErrCode 查出来再更新， 可以在loadById时加悲观锁 查当前审核人的代码 可以抽出来，实现一个接口或者公共类，查询审核人的代码公用 保存产品费用后端需要做校验 删除产品费用是，关联的产品费用进行批量查询 产品费用操作加事务 验证失败直接抛出异常即可 new Money (0) 改为 Money.ZERO 一个方法参数里调用另一个方法时，把另一个方法抽出来 loadById 的时候改成悲观锁, update 的时候再释放掉 需要加个事务， 避免并发 version 乐观锁, 没怎么用， 对性能要求较高，一致性要求较低时可以用 跑批的时候 可以用乐观锁， 多条机器可以并行的跑时可以用 用jdk8 里的LocalDateTime代替jodaTime 张波 与前面三位差不多","tags":[]},{"title":"数据库默认隔离级别","date":"2016-12-20T15:33:40.000Z","path":"2016/12/20/DB-ISOLATION/","text":"1.InnoDB默认是可重复读的（REPEATABLE READ）2.你可以在命令行用–transaction-isolation选项，或在选项文件里，为所有连接设置默认隔离级别。 在my.cfg文件的[mysqld]节里类似如下设置该选项：= &#123;READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE&#125;123```3.用户可以用SET TRANSACTION语句改变单个会话或者所有新进连接的隔离级别```SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125; 4.用下列语句查询全局和会话事务隔离级别@@global.tx_isolation;12SELECT @@session.tx_isolation;SELECT @@tx_isolation; Oracle等多数数据库默认都是读已提交(Read Committed)","tags":[]},{"title":"Hello World","date":"2016-11-29T08:57:15.000Z","path":"2016/11/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"My First Blog","date":"2015-07-29T23:56:29.000Z","path":"2015/07/30/MyFirstBlog/","text":"在Java中如何高效的判断数组中是否包含某个元素代码1ArrayUtils.contains();","tags":[{"name":"hexo","slug":"hexo","permalink":"http://crystalxiaoou.github.io/tags/hexo/"},{"name":"apache commons","slug":"apache-commons","permalink":"http://crystalxiaoou.github.io/tags/apache-commons/"}]}]